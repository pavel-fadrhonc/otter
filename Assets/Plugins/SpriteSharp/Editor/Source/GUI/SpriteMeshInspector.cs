using System;
using System.Linq;
using UnityEditor;
using UnityEngine;
using LostPolygon.SpriteSharp.Database;
using LostPolygon.SpriteSharp.Internal;
using LostPolygon.SpriteSharp.Serialization.Internal;
using LostPolygon.SpriteSharp.TightMeshSettings;
using LostPolygon.SpriteSharp.Utility;
using LostPolygon.SpriteSharp.Utility.Internal;

namespace LostPolygon.SpriteSharp.Gui.Internal {
    /// <summary>
    /// Main SpriteSharp inspector. Wraps over the standard <c>UnityEngine.SpriteInspector</c>
    /// and extends it with tight mesh settings.
    /// </summary>
    [CustomEditor(typeof(Sprite))]
    [CanEditMultipleObjects]
    internal class SpriteMeshInspector : EditorDecorator {
        private static readonly Type _spriteInspectorType = typeof(Editor).Assembly.GetType("UnityEditor.SpriteInspector", true);

        [SerializeField]
        private Sprite[] _currentTargetSprites;

        [SerializeField]
        private Sprite[] _currentTargetSpritesIncludingAlphaSprites;

        [SerializeField]
        private SpriteTightMeshSettings[] _currentSpritesTightMeshSettings;

        [SerializeField]
        private int _platformIndex = int.MinValue;

        private bool _areSettingsDirty;
        private SpriteMeshSettingsDrawer _settingsDrawer;
        private Material _lineMaterial;

        #region Unity methods

        protected override void OnEnable() {
            base.OnEnable();

            if (_platformIndex == int.MinValue) {
                _platformIndex = EditorPreferences.LastSelectedPlatformIndex;
            }

            _lineMaterial = new Material(Shader.Find("GUI/Text Shader"));
            _lineMaterial.hideFlags = HideFlags.HideAndDontSave;
            _lineMaterial.SetTexture("_MainTex", Texture2D.whiteTexture);
        }

        protected override void OnDisable() {
            base.OnDisable();

            CheckForUnappliedChanges();

            if (_lineMaterial != null) {
                DestroyImmediate(_lineMaterial);
            }
        }

        #endregion

        #region Overrides

        protected override Type DecoratedEditorType {
            get {
                return _spriteInspectorType;
            }
        }

        public override void OnInspectorGUI() {
            DatabaseProxy database = DatabaseProxy.Instance;

            // Fallback to standard GUI
            if (database == null) {
                CallDecoratedOnInspectorGUI();
                return;
            }

            // Collect suitable sprites that have tight meshes and are not alpha sprites
            _currentTargetSpritesIncludingAlphaSprites =
                targets
                    .OfType<Sprite>()
                    .Where(sprite => {
                        if (!sprite.IsTextureTightMesh())
                            return false;

                        TextureImporter textureImporter = sprite.texture.GetTextureImporter();
                        return 
                            textureImporter == null || 
                            (textureImporter.DoesTextureHaveAlpha() && textureImporter.IsTextureImporterWithEditableSpriteMode());
                    })
                    .ToArray();

            // Skip alpha sprites
            Sprite[] sprites =
                _currentTargetSpritesIncludingAlphaSprites
                    .Where(sprite => database.GetOpaqueSpriteOfAlphaSprite(sprite) == null)
                    .ToArray();

            // Check if targets sprites are changed
            if (_currentTargetSprites == null || !sprites.SequenceEqual(_currentTargetSprites)) {
                HandleTargetSpritesChanged(sprites);
                _currentTargetSprites = sprites;
            }

            // Draw SpriteSharp inspector
            GUI.enabled = sprites.Length != 0;
            DrawSpriteSharpInspectorGUI(database, sprites);

            // Draw standard SpriteInspector stuff
            GUI.enabled = false;
            EditorGUILayout.HelpBox("Sprite Info", MessageType.None);

            bool isNonValidTargets = targets.Where(o => o == null).ToArray().Length > 0;
            if (!isNonValidTargets) {
                CallDecoratedOnInspectorGUI();
            }
        }

        private void DrawSpriteSharpInspectorGUI(DatabaseProxy database, Sprite[] sprites) {
            EditorGUILayout.HelpBox(SpriteSharp.Internal.Constants.kAssetName + " Settings", MessageType.None);

            bool isDisabled = database.IsProcessingDisabled;

            if (database.IsProcessingDisabled) {
                EditorGUILayout.HelpBox(
                    SpriteSharp.Internal.Constants.kAssetName + " is currently disabled. Changes can't be made. " +
                    "Imported sprites will have meshes generated by standard Unity method. ",
                    MessageType.Warning,
                    true
                );
            }

            bool areSomeSpritesPacked = sprites.Any(sprite => sprite.packed);
            bool areAllSpritesPacked = sprites.All(sprite => sprite.packed);
            if (!isDisabled && areSomeSpritesPacked && EditorApplication.isPlayingOrWillChangePlaymode) {
                EditorGUILayout.HelpBox(
                    "Editing meshes of packed Sprites is not available in Play mode.",
                    MessageType.Warning,
                    true
                );

                if (!areAllSpritesPacked) {
                    if (GUILayout.Button("Deselect Packed Sprites")) {
                        Selection.objects =
                            sprites
                                .Where(sprite => !sprite.packed)
                                .ToArray();
                    }
                }

                isDisabled = true;
            }

            EditorGUI.BeginDisabledGroup(isDisabled);
            if (sprites.Length != 0) {
                Undo.RecordObject(this, "Sprite Mesh Settings");
                DrawSettingsGui(database);
            } else {
                DrawInvalidSpriteGui(database);
            }
            EditorGUI.EndDisabledGroup();

            if (_currentTargetSpritesIncludingAlphaSprites.Length > 0) {
                CreateSettingsDrawer(database);

                // Draw mesh exporter
                GUI.enabled = true;
                EditorGUILayout.HelpBox("Sprite Mesh Export", MessageType.None);
                _settingsDrawer.DrawMeshExport(_currentTargetSpritesIncludingAlphaSprites);
                GUI.enabled = false;
            }
        }

        public override void OnPreviewGUI(Rect rect, GUIStyle background) {
            base.OnPreviewGUI(rect, background);

            if (target == null)
                return;

            Sprite sprite = target as Sprite;
            if (!sprite.IsTextureTightMesh())
                return;

            // Only draw wireframe in big enough rects
            if (rect.width > 64f || rect.height > 64f) {
                DrawSpriteWireframe(rect, sprite);
            }

            // Only draw label in big enough rects
            if (rect.width > 128f || rect.height > 128f) {
                Rect infoStringRect = rect;
                infoStringRect.y -= 5f;
                EditorGUI.DropShadowLabel(infoStringRect, GetInfoStringInternal());
            }
        }

        public override string GetInfoString() {
            if (target == null)
                return "";

            Sprite sprite = target as Sprite;
            if (!sprite.IsTextureTightMesh())
                return DecoratedEditor.GetInfoString();

            return "";
        }

        private string GetInfoStringInternal() {
            if (target == null)
                return "";

            Sprite sprite = (Sprite) target;
            ushort[] triangles = sprite.triangles;
            Vector2[] vertices = sprite.vertices;

            Vector2 min, max;
            float areaTight = MathUtility.CalculateMeshAreaAndBoundingBox(triangles, vertices, out min, out max);
            float areaFullRect = (max.x - min.x) * (max.y - min.y);
            float overdrawRatio = areaTight / areaFullRect;

            string infoString =
                String.Format(
                    "{0}\n({1}x{2}, {3} vertices, {4} triangles,\n{5:F1}% overdraw)",
                    sprite.name,
                    (int) sprite.rect.width,
                    (int) sprite.rect.height,
                    vertices.Length,
                    triangles.Length / 3,
                    overdrawRatio * 100f
                    );

            return infoString;
        }

        #endregion

        private void DrawSettingsGui(DatabaseProxy database) {
            // Platform select
            int oldPlatformIndex = _platformIndex;
            _platformIndex =
                EditorGUILayoutExtensions.BeginPlatformGrouping(
                    _platformIndex,
                    BuildPlatformsUtility.ValidBuildPlatforms,
                    new GUIContent("Default"));
            if (oldPlatformIndex != _platformIndex) {
                EditorPreferences.LastSelectedPlatformIndex = _platformIndex;
            }

            BuildTargetGroup buildTargetGroup = BuildPlatformsUtility.GetDefaultBuildTargetGroup();
            if (_platformIndex != -1) {
                buildTargetGroup = BuildPlatformsUtility.ValidBuildPlatforms[_platformIndex].BuildTargetGroup;
            }

            // Settings
            CreateSettingsDrawer(database);

            bool isChanged =
                _settingsDrawer.DrawSettings(
                    _currentTargetSprites,
                    _currentSpritesTightMeshSettings,
                    buildTargetGroup,
                    true
                );

            GUILayout.Space(5f);
            EditorGUILayoutExtensions.EndPlatformGrouping();

            if (isChanged) {
                _areSettingsDirty = true;
                EditorUtility.SetDirty(database);
            }

            DrawRevertApplyButtons();
        }

        private void DrawRevertApplyButtons() {
            EditorGUI.BeginDisabledGroup(!_areSettingsDirty);
            {
                GUILayout.Space(3f);
                GUILayout.BeginHorizontal();
                {
                    GUILayout.FlexibleSpace();

                    if (GUILayout.Button("Revert")) {
                        RevertChanges();
                    }

                    if (GUILayout.Button("Apply")) {
                        ApplyChanges();
                    }
                }
                GUILayout.EndHorizontal();
            }
            EditorGUI.EndDisabledGroup();
        }

        private void DrawInvalidSpriteGui(DatabaseProxy database) {
            if (targets.Length > 1) {
                EditorGUILayout.HelpBox("Selected sprites textures are not using Tight mesh type, or do not have alpha channel.", MessageType.Info, true);
            } else {
                Sprite targetSprite = (Sprite) target;
                Sprite opaqueSprite = database.GetOpaqueSpriteOfAlphaSprite(targetSprite);
                if (opaqueSprite != null) {
                    DrawAlphaSpriteGui(database, targetSprite, opaqueSprite);
                } else {
                    EditorGUILayout.HelpBox("Selected sprite texture is not using Tight mesh type, or has no alpha channel.", MessageType.Info, true);
                }
            }
        }

        private static void DrawAlphaSpriteGui(DatabaseProxy database, Sprite alphaSprite, Sprite opaqueSprite) {
            // Make sure alpha sprite has not AlphaSprite set itself
            SpriteTightMeshSettings alphaSpriteTightMeshSettings = database.GetTightMeshSettings(alphaSprite, false);
            if (alphaSpriteTightMeshSettings != null) {
                alphaSpriteTightMeshSettings.PlatformSharedTightMeshSettings.AlphaSprite = null;
            }

            // Check if opaque sprite has lost connection with alpha sprite for some reason
            SpriteTightMeshSettings opaqueSpriteTightMeshSettings = database.GetTightMeshSettings(opaqueSprite, false);
            if (opaqueSpriteTightMeshSettings != null) {
                opaqueSpriteTightMeshSettings.PlatformSharedTightMeshSettings.AlphaSprite = alphaSprite.ToSpriteLazyReference();
            }

            GUI.enabled = true;
            EditorGUILayout.HelpBox("Selected sprite is the non-opaque part of other sprite.", MessageType.Info, true);
            if (GUILayout.Button("Select Primary Sprite")) {
                Selection.activeObject = opaqueSprite;
            }
            GUI.enabled = false;
        }

        private void DrawSpriteWireframe(Rect rect, Sprite sprite) {
            float fittingScale = Mathf.Min(rect.width / sprite.rect.width, rect.height / sprite.rect.height);
            Rect position = new Rect(rect.x, rect.y, sprite.rect.width * fittingScale, sprite.rect.height * fittingScale) {
                center = rect.center
            };

            ushort[] triangles = sprite.triangles;
            Vector2[] vertices = sprite.vertices;
            float spriteScale = sprite.rect.height / position.height;

            // Transform sprite vertices to Rect coordinates
            Vector2 pivot = new Vector3(position.x, position.y, 0f);
            Vector2 spritePivotScaled = sprite.pivot / spriteScale;
            float spritePixelsPerUnitScaled = sprite.pixelsPerUnit / spriteScale;

            for (int i = 0; i < vertices.Length; i++) {
                Vector2 vertex = vertices[i] * spritePixelsPerUnitScaled + spritePivotScaled;
                vertex.y = vertex.y - position.height;
                vertices[i] = vertex;
            }

            Color meshColor = new Color32(104, 138, 188, 255);
            _lineMaterial.color = meshColor;
            _lineMaterial.SetPass(0);

            GL.wireframe = true;
            GL.PushMatrix();
            {
                GL.MultMatrix(Matrix4x4.TRS(pivot, Quaternion.identity, new Vector3(1f, -1f, 1f)));

                GL.Begin(GL.TRIANGLES);
                {
                    for (int i = 0; i < triangles.Length; i++) {
                        GL.Vertex3(vertices[triangles[i]].x, vertices[triangles[i]].y, 0f);
                    }
                }
                GL.End();
            }
            GL.PopMatrix();
            GL.wireframe = false;
        }

        private void CreateSettingsDrawer(DatabaseProxy database) {
            if (_settingsDrawer == null) {
                _settingsDrawer =
                    new SpriteMeshSettingsDrawer(
                        CheckForUnappliedChanges,
                        () => EditorUtility.SetDirty(database),
                        () => CopyCurrentSpriteMeshSettings(_currentTargetSprites, ref _currentSpritesTightMeshSettings),
                        () => _areSettingsDirty = true,
                        Repaint
                        );
            }
        }

        private void HandleTargetSpritesChanged(Sprite[] newTargets) {
            CreateDecoratedInspector();
            CheckForUnappliedChanges();
            CopyCurrentSpriteMeshSettings(newTargets, ref _currentSpritesTightMeshSettings);
        }

        private bool CheckForUnappliedChanges() {
            if (!_areSettingsDirty)
                return true;

            bool isValid = false;
            string fileNames;
            if (_currentTargetSprites.Length > 1) {
                fileNames = String.Format("{0} sprites.", _currentTargetSprites.Length);
            } else {
                fileNames = "\r\n";
                foreach (Sprite sprite in _currentTargetSprites) {
                    if (sprite == null)
                        continue;

                    isValid = true;
                    fileNames +=
                        String.Format(
                            "'{0}:[{1}]'\r\n",
                            AssetDatabase.GetAssetPath(sprite.texture),
                            sprite.name
                            );
                }
            }

            if (!isValid)
                return true;

            if (EditorUtility.DisplayDialog(
                "Unapplied Tight Sprite Mesh Settings",
                "Unapplied sprite mesh settings for " + fileNames,
                "Apply",
                "Revert"
                )) {
                ApplyChanges();
                return true;
            } else {
                RevertChanges();
                return false;
            }
        }

        private void RevertChanges() {
            _areSettingsDirty = false;
            CopyCurrentSpriteMeshSettings(_currentTargetSprites, ref _currentSpritesTightMeshSettings);
        }

        private void ApplyChanges() {
            _areSettingsDirty = false;
            DatabaseProxy database = DatabaseProxy.Instance;
            Undo.RecordObject(database, SpriteSharp.Internal.Constants.kAssetName + " Database");
            for (int i = 0; i < _currentSpritesTightMeshSettings.Length; i++) {
                SpriteTightMeshSettings originalSettings = database.GetTightMeshSettings(_currentTargetSprites[i]);
                _currentSpritesTightMeshSettings[i].CopyTo(originalSettings);
            }

            EditorUtility.SetDirty(database);
            Undo.RecordObject(database, SpriteSharp.Internal.Constants.kAssetName + " Database");

            EditorTextureUtility.ReimportDistinctTextures(_currentTargetSprites.Select(sprite => sprite.texture));
        }

        private static void CopyCurrentSpriteMeshSettings(Sprite[] newTargets, ref SpriteTightMeshSettings[] settings) {
            DatabaseProxy database = DatabaseProxy.Instance;
            if (settings == null || settings.Length != newTargets.Length) {
                settings = new SpriteTightMeshSettings[newTargets.Length];
            }
            for (int i = 0; i < settings.Length; i++) {
                settings[i] = new SpriteTightMeshSettings();
                SpriteTightMeshSettings temp = database.GetTightMeshSettings(newTargets[i]);
                if (temp == null)
                    continue;

                temp.CopyTo(settings[i]);
            }
        }
    }
}